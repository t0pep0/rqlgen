package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

const (
	tagRex  = `gorethink:"([a-zA-Z0-9\-\_]*)[,]?(omidempty)?[a-zA-Z0-9\-\_\,]*"`
	typeRex = `rqlgen:"(number|string|time|map_string|map_number|map_time|map_bool|map_rql|array_string|array_number|array_time|array_bool|array_rql|bool|rql)"`
)

var (
	pFileName      = flag.String("file", "", "file name")
	pTypeName      = flag.String("type", "", "type name")
	pPolyField     = flag.String("poly", "", "polymorphic field")
	rexp           *regexp.Regexp
	rexpType       *regexp.Regexp
	dbType2Runtime = map[string]string{
		"string": "string",
		"number": "float64",
		"bool":   "bool",
		"time":   "time.Time",
	}
)

func getFieldType(field ast.Expr) string {
	switch v := field.(type) {
	case *ast.Ident:
		return v.Name
	case *ast.StarExpr:
		return "*" + getFieldType(v.X)
	case *ast.SelectorExpr:
		return getFieldType(v.X) + "." + v.Sel.Name
	case *ast.MapType:
		return "map[" + getFieldType(v.Key) + "]" + getFieldType(v.Value)
	case *ast.SliceExpr:
		return "[]" + getFieldType(v.X)
	}
	return ""
}

func getFieldTag(field *ast.Field) (rqlgenRes [3]string, err error) {
	rawTag := strings.Trim(field.Tag.Value, "`")
	out := rexp.FindStringSubmatch(rawTag)
	if len(out) < 3 {
		err = fmt.Errorf("Please, set valid gorethink tag for %v.%v\n", *pTypeName, field.Names[0].Name)
		return rqlgenRes, err
	}
	rqlgenRes[0] = out[1]
	rqlgenRes[1] = out[2]
	out = rexpType.FindStringSubmatch(rawTag)
	if len(out) < 2 {
		err = fmt.Errorf("Please, set valid rqlgen tag for %v.%v\n", *pTypeName, field.Names[0].Name)
		return rqlgenRes, err
	}
	rqlgenRes[2] = out[1]
	return rqlgenRes, nil
}

func readStruct(obj *ast.Object, polyField string) (strct *Struct, err error) {
	if obj == nil {
		return nil, errors.New("Not found target struct")
	}
	strct = new(Struct)
	strct.Name = obj.Name
	strct.ShortName = strings.ToLower(string(strct.Name[0]))
	if obj.Kind == ast.Typ {
		if t, ok := obj.Decl.(*ast.TypeSpec); ok {
			if s, ok := t.Type.(*ast.StructType); ok {
				for _, field := range s.Fields.List {
					f := new(Field)
					f.Name = field.Names[0].Name
					tags, err := getFieldTag(field)
					if err != nil {
						return nil, err
					}
					f.DBName = tags[0]
					f.Omidempty = len(tags[1]) != 0
					f.DBType = tags[2]
					f.Type = getFieldType(field.Type)
					f.IsPolymorphic = f.Name == polyField

					strct.Fields = append(strct.Fields, f)
				}

			} else {
				return nil, errors.New("Tagret isn't struct")
			}
		} else {
			return nil, errors.New("Tagret isn't type")
		}
	} else {
		return nil, errors.New("Tagret isn't type")
	}
	return strct, nil
}

func extractImport(imp *ast.ImportSpec) string {
	if imp.Name != nil {
		return fmt.Sprintf("\t%v %v\n", imp.Name.Name, imp.Path.Value)
	} else {
		return fmt.Sprintf("\t%v\n", imp.Path.Value)
	}
	return ""
}

func writeHeader(gen io.Writer, src *ast.File) {
	fmt.Fprintf(gen, "//This file is generated by rqlgen. DO NOT EDIT!\n")
	fmt.Fprintf(gen, "package %v\n", src.Name.Name)
	fmt.Fprintf(gen, "import (\n")
	for _, imp := range src.Imports {
		fmt.Fprintf(gen, extractImport(imp))
	}
	fmt.Fprintf(gen, "\tgenrqlerrors \"errors\"\n")
	fmt.Fprintf(gen, ")\n\n")
}

func main() {
	flag.Parse()
	var genFileName = strings.TrimSuffix(*pFileName, ".go") + "_rqlgen.go"

	rexp = regexp.MustCompile(tagRex)
	rexpType = regexp.MustCompile(typeRex)

	fset := token.NewFileSet()
	aFile, err := parser.ParseFile(fset, *pFileName, nil, parser.ParseComments)
	if err != nil {
		fmt.Println("Unable to open file", err)
		os.Exit(1)
	}
	obj := aFile.Scope.Lookup(*pTypeName)
	strct, err := readStruct(obj, *pPolyField)
	if err != nil {
		fmt.Println("Unable to parse file", err)
		os.Exit(2)
	}
	gen, err := os.Create(genFileName)
	if err != nil {
		fmt.Println("Unable to create file", err)
		os.Exit(3)
	}
	defer func() {
		gen.Close()
		exec.Command("goimports", "-w", genFileName).Run()
		exec.Command("gofmt", "-s", "-w", genFileName).Run()
	}()

	writeHeader(gen, aFile)
	strct.writeMarshal(gen)
	strct.writeUnmarshal(gen)

}
